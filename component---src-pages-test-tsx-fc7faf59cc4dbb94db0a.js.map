{"version":3,"file":"component---src-pages-test-tsx-fc7faf59cc4dbb94db0a.js","mappings":"2JAGO,MAAMA,EAAe,IAExBC,EAAAA,cAAAA,EAAAA,SAAAA,KACEA,EAAAA,cAAAA,OAAAA,CAAMC,QAAQ,UACdD,EAAAA,cAAAA,OAAAA,CAAME,KAAK,WAAWC,QAAQ,wCAC9BH,EAAAA,cAAAA,QAAAA,KAAAA,mBACAA,EAAAA,cAAAA,OAAAA,CACEI,KAAK,0EACLC,IAAI,aACJC,UAAU,0EACVC,YAAY,c,2FCepB,UAxBuCC,IAA6B,IAA5B,KAAEC,GAAqB,EAqB7D,OApBAC,iBACE,MAAMC,QAAyBC,eAC/B,IAGE,MAAMC,EAAO,mCACPC,QAAgBH,EAAiBI,UAAU,SAAUF,GAC3DG,QAAQC,IAAI,CAAEH,YACd,MACMI,EADuB,IAAIC,gBAAgBR,EAAkBG,GACjCM,QAChC,kJAGFJ,QAAQC,IAAI,OAAQC,EAGtB,CAFE,MAAOG,GACPL,QAAQK,MAAMA,EAChB,CACF,CAEAC,GACOtB,EAAAA,cAAAA,OAAAA,KAAAA,cAAwB,C","sources":["webpack://encryption/./src/components/Head.tsx","webpack://encryption/./src/pages/test.tsx"],"sourcesContent":["import * as React from 'react';\nimport type { HeadFC } from 'gatsby';\n\nexport const Head: HeadFC = () => {\n  return (\n    <>\n      <meta charSet=\"utf-8\" />\n      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n      <title>Encryption Tool</title>\n      <link\n        href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css\"\n        rel=\"stylesheet\"\n        integrity=\"sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi\"\n        crossOrigin=\"anonymous\"\n      />\n    </>\n  );\n};\n","import * as React from 'react';\nimport type { PageProps } from 'gatsby';\nimport { graphql } from 'gatsby';\n\nconst IndexPage: React.FC<PageProps> = ({ data }: { data: any }) => {\n  async function main() {\n    const fullSodiumHelper = await sodiumHelper();\n    try {\n      //fullSodiumHelper.encryptUsingKeyAsHex;\n      //const KEY_HEX = '724b092810ec86d7e35c9d067702b31ef90bc43a7b598626749914d6a3e033ed';\n      const salt = 'd27d6e8e1427d1c7098f2c8aeccbe198';\n      const KEY_HEX = await fullSodiumHelper.deriveKey('secret', salt); //TODO secretPassPhrase\n      console.log({ KEY_HEX });\n      const slimCryptHelperInner = new SlimCryptHelper(fullSodiumHelper, KEY_HEX);\n      const temp = slimCryptHelperInner.decrypt(\n        '94120917afb093b861b62f87b5a0cc001e84f26e62e5b54b5521847068ab1e3e74965f718c8337450af3cfefdd93a810000d68d3ba990730bd029ff2a052b0f9aefa11d84c3f47',\n      );\n      //const temp = slimCryptHelperInner.encrypt('Pretend this is a secret!\\nShhh!'); // TODO Remove\n      console.log('temp', temp); // TODO\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  main();\n  return <main>see console</main>;\n};\n\nexport default IndexPage;\n\nexport { Head } from '../components/Head';\n\n/*\n  const encrypted = encrypt('PUZZTRADBECOCONTSNAKFLAVAWESATTESHADSUPPTIGEWOLF0790VOLCHAMMVELVCHAPMIXTOCEA0379ANGEBURSSONGASPE', key);\n  console.log({ encrypted });\n  console.log(decrypt(encrypted, key));\n\nI want ITS. \nI want a one-time pad approach to encrypting and decrypting.\nIt should support any character in the plaintext, including digits, spaces, punctuation, etc.\nAssume my key is completely random and at least as long as the plaintext. \nI want to support keys that are longer than the plaintext.\nAssume the key will only be used once and that both sender and receiver possess it.\nOnly rely on non-deprecated functions.\nOnly use functions available in Gatsby.\nWrite TypeScript functions `encrypt` and `decrypt` such that the encrypted value is encoded to contain only uppercase characters A-Z.\n*/\n"],"names":["Head","React","charSet","name","content","href","rel","integrity","crossOrigin","_ref","data","async","fullSodiumHelper","sodiumHelper","salt","KEY_HEX","deriveKey","console","log","temp","SlimCryptHelper","decrypt","error","main"],"sourceRoot":""}